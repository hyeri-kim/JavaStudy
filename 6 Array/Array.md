배열을 선언하면 그 배열의 저장공간에는 첫번째 저장공간의 주소가 들어가 있다.

> **배열의 시작주소(첫번째 저장공간의 주소)만 stack 영역에 담기고 나머지 주소는 heap 영역에 칸 수가 지정되어 담긴다.**
> 

e.g.

int arPrice[] = { 3, 4, 1, 2 };

arPrice : 주소값을 담고 있는 공간

arPrice+0 → 0번째 주소

arPrice+1 → 1번째 주소

arPrice+2 → 2번째 주소

arPrice+3 → 3번째 주소

- C언어는 값을 참조할 때 `*` 사용
    - *(arPrice+0) → 0번째 주소의 값을 참조
    - ***(arPrice+0) == 3** 으로 볼 줄 알아야 함 !!!
- JAVA는 값을 참조할 때 `[]` 사용
    - arPrice[0] → 0번째 주소의 값을 참조
    - **arPrice[0] == 3** 으로 볼 줄 알아야 함 !!!

**C언어** : *(arPrice+0) == **자바** : arPrice[0]

---

인덱스(index) 주소가 0부터 시작하는 이유?

변수명이 시작주소를 가지고 있기 때문에 포인터 연산을 했을 때 +0이다. 그걸 대괄호로 치환하게 되면 0부터 시작할 수 밖에 없다.

---

> **배열의 사용**
> 
- 같은 타입의 값들을 한번에 저장하기 위해 사용.
    
    → **같은 타입의 변수들**이 **여러번 선언** 되었을 때 배열이 생각나야 한다 !
    

> **배열의 선언**
> 
1. **자료형[] 배열명 = new 자료형[길이];**
    
    내가 초기화 하지 않아도 안에 있는 값들이 자동으로 초기화 됨.
    
    ```java
    int[] arData = new int[4];
    // new는 기타연산자 → heap메모리 영역에 저장
    ```
    
2. **자료형 배열명[] = {값1, 값2, ...};**
    
    내가 원하는 지정 값이 있을 때는 중괄호 사용.
    
    ```java
    int arPrice[] = { 1000, 2000, 3500 }; // 선언과 동시에 초기화
    ```
    
3. **자료형[] 배열명;**

> **주소값 해석**
> 

e.g.    [I@7852e922

- `[` : 이 주소는 '배열'의 주소다.
- `I` : 이 배열은 Integer타입이다.
- `@` : 구분점
- `7852e922` ← 이게 이 배열의 주소다.

## **2차원 배열**

> **배열의 선언**
> 

1.

```java
자료형 [][] 배열명 = new 자료형[행][열];
```

2.

```java
자료형 [][] 배열명 = {
	{값1, 값2, ...},
	{값3, 값4, ...}
};
```
